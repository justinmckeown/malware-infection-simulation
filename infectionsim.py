#!/usr/bin/env python

import random
import infected

#NOTE: This code was written to roughly simulate the infection behaviour of a piece of hypothetical malware I was analysing. The malware is spread willfully by paid mules who infect secondary users.
#NOTE: The purpose of this script is to work out roughly how long it will take for infection to reach appropriate density of spread among owners of targeted systems 

#counters to keep track of the day and the week. This will be useful for trying to say how long it took a sim8ulated infection to reach our infeciton level goal 
day_count = 1 
week_count = 1

#initial number of infected devices introduced to population
initial_infected = 50

#target number of infected users
infection_target = 1095000

#counter to keep track of how many poeple are infected
infection_count = 0

#infection id. We assign this unique tag to each newly created infected person/device. We do this so we can trace who has infected who and how successful some 'people' have been at infecting others
infected_id = 0

#Function for getting current 'infected_id' and returning a new one that's +1 of the previous
def get_infected_id(n):
    the_id = n+1
    return the_id

#function to get a new infection rate for the infected caller
def get_infection_rate(n):
    return random.randint(0, n)

#function to generate a social_circle size. This is used to try and contain the predicted spread of the malware to something relaistic. to this end Dunbars number is used as the confining scale 
#primary infectors should have a bigger infection pool because they're activley seeking poeple to infect.
def get_social_circle_size(n):
    if n != 'primary':
        return random.randint(100,250)
    else:
        return random.randint(200, 500)

#Function to simulate an infection attempt. When an infected user shares a link there is no garuntee the person recieving the link will click on it. There is therefore a 1 in 2 chacge of them clicking it
#or declining the link. The below funciton is therefore called each time an infection attempt is made
def attempt_infection():
    attempt = random.randint(0,1)
    if attempt > 0:
        return True
    else:
        return False
print("Running infection simulation...")

#make an array of the primary infected users. In my scenario these poeple are paid to spread the malware, so they behave different;y than the users the infect, as their rate of sharing the malware should
#be much more intense:
primary_infected = []
for i in range(initial_infected):
    #increase infected id by 1 each time round the loop to keep each id unique
    infected_id = infected_id + 1
    #print(("DEBUGG: INFECTION ID FOR NEXT PRIMARY INFECTION {}".format(infected_id)))
    #set the effectivness of the primary infectors to three per day for the first week. After this their infection rate will decrase
    primary_infected.append(infected.Infected('primary', 3, infected_id, 0, get_social_circle_size('primary')))

#a new list to hold any newley created infections.
newley_infected = []

#a list to hold all secondary infections
secondary_infected = []

#a Variable to trigger infections that only happen on a weekly basis
new_week = True

#for debugging only
loop_count = 0

#main loop to run infection simulation
while infection_count < infection_target:
    #print("DEDUG: Loopcount: {}".format(loop_count))

    #first check the day and keep track of which week we're in
    if day_count == 8:
        week_count = week_count + 1
        day_count = 1
        new_week = True

    #Loop thorugh all primary infected and begin simulating infection process by primary users
    for sick in primary_infected:
        #PRIMARY INFECTORS CODE BEGINS HERE...
        #In the early stages of infecting, primary infectors will have a larger pool of people to choose to share the malware with. 
        #As time goes on this will become less so their ability to infect will drop off
        #In week one Primary infectors will be very vigarous in their attempts to infect so their infection rate is set to three attempts per day
        #As this was set in their initialisation (line 59) there is no need to set any special conditions for week one. only for the following weeks
        #by the time week two arrives, the Primary infectors will have exhausted most of their pool of close friends, family and colleagues to share the app with. 
        #They will therefore have to work harder to find other people at the margins of the social circle to share the app with.
        #Their infection rate therefore slows down.
        #The Final assumption is that primary infectors will be most active in the first month. After that they'll slow down and behave like secondary infectors. 
        #This is because they are no longer being inventivised to share the malware. Allo of this is artiulated through the code structure below 

        if week_count < 5:
            #print("DEBUG: Entered 'if week_count is less than 5'")
            if week_count == 2:
                #reset the 'primariy_infectors' infection rate to be less effective. Introduce variance in different primary infectors infection rate 
                new_infection_rate = get_infection_rate(2)
                sick.infection_rate = new_infection_rate

            if week_count > 2:
                #reset the 'primary_infectors' rate to be even less effective. Continue varied infeciton rate 
                new_infection_rate = get_infection_rate(1)
                sick.infection_rate = new_infection_rate

            #perform infection simulation by primary infectors
            infection_attempts = sick.infection_rate
            if infection_attempts > 0 and sick.social_circle > 0:
                #use each infection rate as an attempt to infect someone with the malware....
                while infection_attempts > 0 and sick.social_circle > 0:
                    infect = attempt_infection()
                    #regardless of whether the infeciton is successful or not you must deduct one from the social circle size. 
                    sick.social_circle = sick.social_circle - 1
                    if infect:
                        infected_id = infected_id + 1
                        #print(("DEBUGG: INFECTION ID FOR NEXTSECONDARY  INFECTION {}".format(infected_id)))
                        #set infection rate of secondary infected to be between 0 and 1. It's assumed they will be much less active abotu sharing monzo sign up links than primary infectors
                        rate = get_infection_rate(1)
                        newley_infected.append(infected.Infected('secondary', rate, infected_id, sick.infection_id, get_social_circle_size('secondary')))
                    infection_attempts = infection_attempts - 1
        else:
            if new_week:
                #perform infection simulation by primary infectors
                infection_attempts = sick.infection_rate
                if infection_attempts > 0 and sick.social_circle > 0:
                    while infection_attempts > 0 and sick.social_circle > 0:
                        infect = attempt_infection()
                        sick.social_circle = sick.social_circle -1
                        if infect:
                            infected_id = infected_id + 1
                            #print(("DEBUGG: INFECTION ID FOR NEXT SECONDARY INFECTION {}".format(infected_id)))
                            rate = get_infection_rate(1)
                            newley_infected.append(infected.Infected('secondary', rate, infected_id, sick.infection_id, get_social_circle_size('secondary')))
                        infection_attempts = infection_attempts - 1
                #NOTE: leave setting of `new_week` to `False` for the secondary infected otherwise their codeblock wont fire.  
            

    #SECONDARY INFECTED CODE BEGINS HERE...
    #secondary_infectors will infect at a much slower rate between zero and one infections per week. 
    #this only fires once a week so in reading the output you'll notice a constant rate in secondary infections for multiple entires, until it fires again in the following week
    if new_week:
        for sick in secondary_infected:
            infection_attempts = sick.infection_rate
            if infection_attempts > 0 and sick.social_circle > 0:
                while infection_attempts > 0 and sick.social_circle > 0:
                    infect = attempt_infection()
                    #minus one from the social circle size count each time the secondary infected attempts to share a link in there social circle.
                    sick.social_circle = sick.social_circle - 1
                    if infect:
                        infected_id = infected_id + 1
                        #print(("DEBUGG: INFECTION ID FOR NEXT TERTIARY INFECTION {}".format(infected_id)))
                        #set infection rate for tertiary infected...
                        rate  = get_infection_rate(1)
                        newley_infected.append(infected.Infected('tertiary', rate, infected_id, sick.infection_id, get_social_circle_size('tertiary')))
                    infection_attempts = infection_attempts - 1
        #set new week to false so that secondary infection attempts only occur once per week
        new_week = False

    #print(("Newley_infected size BEFORE DELETE: {}").format(len(newley_infected)))
    #finally append the_infected array
    if len(newley_infected) > 0:
        #print("firing extend secondary_infected array")
        secondary_infected.extend(newley_infected)
    #for thoroughness empty the 'newley_infected' list before the next itteration
    del newley_infected[:]

    #print(("Newley_infected size AFTER DELETE: {}").format(len(newley_infected)))
    #update total infection count
    infection_count = (len(primary_infected) + len(secondary_infected)) 

    #end of day report:
    print("WEEK: {}".format(week_count))
    print("DAY: {} ".format(day_count))
    print("PRIMARY INFECTED: {}".format(len(primary_infected)))
    print("SECONDARY INFECTED: {}".format(len(secondary_infected)))
    print("TOTAL INFECTED: {}".format(infection_count))
    print("\n")


    #finally, at end of the day clock the day has ended by adding one
    day_count = day_count + 1

    #update the loopcount. This is only for debugging purposes and should normally be commented out
    loop_count = loop_count + 1
#print outcome stats
print ("************************************ INFECTED REPORT ***************************")
#for a in primary_infected:
#    a.print_infection_details()

#for p in secondary_infected:
#    p.print_infection_details()
print("****************************************** END ***********************************")
print("************************ FINAL OUTCOME **************************************")
print("WEEK: {}".format(week_count))
print("DAY: {} ".format(day_count))
print("FINAL TOTAL INFECTED: {}".format(infection_count))
