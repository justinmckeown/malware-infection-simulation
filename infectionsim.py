#!/usr/bin/env python3

import random
import infected

#NOTE: This code was written to roughly simulate the infection behaviour of a piece of hypothetical malware I was analysing. The malware is spread willfully by paid mules who infect secondary users.
#NOTE: The purpose of this script is to work out roughly how long it will take for infection to reach appropriate density of spread among owners of targeted systems 

#counters to keep track of the day and the week. This will be useful for trying to say how long it took a simulated infection to reach our infeciton level goal 
day_count = 1 
week_count = 1

#initial number of infected devices introduced to population by malware mules
initial_infected = 0

#target number of infected users
infection_target = 0 

#number of iphone users in simulation
iphone_users = 45

#number of android users in simulation
android_users = 45

#number of other phone users (eg windows phone users) in simulation
other_users = 10

#if no percentages are set per phone
everyone_has_same_phone = 100

#target phone
target_device = "a"

#counter to keep track of how many poeple are infected
infection_count = 0

#infection id. We assign this unique tag to each newly created infected person/device. We do this so we can trace who has infected who and how successful some 'people' have been at infecting others
infected_id = 0

verbose_mode = True


#function to process the devision of phones in circulation
def user_has_target_phone(a,n,o,t):
    infection_chance = 100
    infected = False
    if t == 'a':
        infection_chance = a
    elif t == 'n':
        infection_chance = n
    elif t== 'o':
        infection_chance = o
    else:
        infection_chance = 100
    #if the infection ratio is within range eg 30% chance ask if the number lect than 30 if it is then its infected
    am_i_infected = random.randint(0, 100)
    if infection_chance <= am_i_infected:
        return True
    else:
        return False

def get_targeted_platform(w):
    if w == 'a':
        return 'iOS'
    elif w == 'n':
        return 'Android'
    elif w == 'o':
        return 'Other'
    else:
        return 'all (default)'


#function to get a new infection rate for the infected caller
def get_infection_rate(n):
    return random.randint(0, n)

#function to generate a social_circle size. This is used to try and contain the predicted spread of the malware to something relaistic. To this end 'Dunbar's Number' is used as the confining scale
#For a link to the relevent paper on Dunbars number see README file
#primary infectors should have a bigger infection pool because they're activley seeking poeple to infect.
def get_social_circle_size(n):
    if n != 'primary':
        return random.randint(100,250)
    else:
        return random.randint(200, 500)

#Function to simulate an infection attempt. When an infected user shares a link there is no garuntee the person recieving the link will click on it. There is therefore a 1 in 2 chance of them clicking it
#or declining the link. The below funciton is therefore called each time an infection attempt is made
def attempt_infection():
    attempt = random.randint(0,1)
    if attempt > 0:
        return True
    else:
        return False

print("************************************************************************************************************************")
print("************************************************************************************************************************")
print("*****  *****   ********    ********   ***************        ****  ***  *****   ****************************************")
print("*****   ***    *******  **  *******   **************  ****************   ***    ****************************************")
print("*****    *     *****   ****  *******  **************         ****  ***    *     ****************************************")
print("*****  *   *   *****          ******  *********************  ****  ***  *    *  ****************************************")
print("*****  ******  ****   ******   *****  *********************  ****  ***  ******  ****************************************")
print("*****  ******  ***   ********   ****        *********        ****  ***  ******  ******************************JMcK2019**")
print("******************************************************************************************************Version 1.2 Beta**")
print("************************************************************************************************************************")
print("\n")
print("This calculates how long it will appeoximately take a piece of malware to spread between mobile devices, where the method of spreading is reliant on social contact between mobile device owners\n")

#USER INPUT LOOP TO SET BASIC VALUES FOR SIMULATION
#boolean to keep the user while loop running
user_input_incomplete = True
input_value = True
base_numbers_incomplete = True
#Loop for getting input from the User
while user_input_incomplete == True:
    if input_value:
        verbose = input("Do you want to run in versbose mode with constant feedback during the calculation? (Y or N) \n")
        if verbose == 'N' or verbose == 'n':
            verbose_mode = False
        else:
            verbose_mode = True

        while base_numbers_incomplete:
            initial_infected = int(input("How many primary infected devices will be used to start the spreading the malware?\n"))
            infection_target = int(input("What is your target number of infected devices?\n"))
            print("please confirm the following is correct\n")
            print(("you wish to infect {} devices and you will be introducing {} infected devices to initiate mass infection").format(infection_target, initial_infected))
            details_correct = input("is this correct? ('Y' or 'N')\n")
            if details_correct == 'Y' or details_correct == 'y':
                base_numbers_incomplete = False
            else:
                print("OK. Please re-enter the details\n")

        target_platform = input("The script assumes that the malware targets all platforms. You can however simulate the process of targeting a single mobile platform. Do you wish to do this (Y or N)?\n")
        if target_platform == 'Y' or target_platform == 'y':
            target_device = input("which platform would you like to target? 'a' = Apple, 'n' = Android, 'o' = other\n")
        else:
            target_device = 'd'

        set_ratios = input("the default ratio of iOS to Android and other platforms is 45% Apple, 45% Android, 10% other. Would you like to change this? ('Y' or 'N')\n")

        if set_ratios == 'Y' or set_ratios == 'y':
            adds_to_100 = False
            while adds_to_100 == False:
                print("You will be asked for a percentage value for the users who have 'iOS', 'Android' and 'Other'. These must add up to 100%. For example for 100% android Answer '100'\n")
                iphone_users = int(input("what percentage of users in the simulation are 'iOS' users?\n"))
                android_users = int(input("what percentage of users in the simulation are 'Android' users?\n"))
                other_users = int(input("what percentage of users in the simulation are 'other' users?\n"))
                if (iphone_users+android_users+other_users == 100):
                    adds_to_100 = True
                else:
                    print("The entered value's for the three platforms do not add up to 100. Please enter the values again. They must add to 100 percent\n")

    print("Please confirm the following:\n")
    print(("Target number of infected devices: {}").format(infection_target))
    print(("Number of 'mules' used to start infection: {}").format(initial_infected))
    print(("You wish to target user with {} devices").format(get_targeted_platform(target_device)))
    print("The percentage of iOS, Android and Other users in the simulation is")
    print(("iOS: {}%").format(iphone_users))
    print(("Android: {}%").format(android_users))
    print(("Other: {}%").format(other_users))

    complete_input = input("If the above is correct type 'Y' to run the calculation. If its incorrect type 'N' to reinput all the values. Ready to run caculation? (Y or N)\n")
    if complete_input == 'Y' or complete_input == 'y':
        user_input_incomplete = False
    elif complete_input == 'N' or complete_input == 'n':
        print("OK, re-input values:")
        input_value = True
    else:
        input_value = False
        print("input must be 'Y' or 'N'")

#make an array of the primary infected users. In my scenario these poeple are paid to spread the malware, so they behave differently than the users they infect, as their rate of sharing the malware should
#be much more intense:
primary_infected = []
for i in range(initial_infected):
    #increase infected id by 1 each time round the loop to keep each id unique
    infected_id = infected_id + 1
    #print(("DEBUGG: INFECTION ID FOR NEXT PRIMARY INFECTION {}".format(infected_id)))
    #set the effectivness of the primary infectors to three per day for the first week. After this their infection rate will decrase
    primary_infected.append(infected.Infected('primary', 3, infected_id, 0, get_social_circle_size('primary')))

#a new list to hold any newley created infections.
newley_infected = []

#a list to hold all secondary infections
secondary_infected = []

#a Variable to trigger infections that only happen on a weekly basis
new_week = True

#for debugging only
loop_count = 0

#main loop to run infection simulation
while infection_count < infection_target:
    #print("DEDUG: Loopcount: {}".format(loop_count))
    #first check the day and keep track of which week we're in
    if day_count == 8:
        week_count = week_count + 1
        day_count = 1
        new_week = True

    #Loop thorugh all primary infected and begin simulating infection process by primary users
    for sick in primary_infected:
        #PRIMARY INFECTORS CODE BEGINS HERE...
        #In the early stages of infecting, primary infectors will have a larger pool of people to choose to share the malware with. 
        #As time goes on this will become less so their ability to infect will drop off
        #In week one Primary infectors will be very vigarous in their attempts to infect so their infection rate is set to three attempts per day
        #As this was set in their initialisation (line 59) there is no need to set any special conditions for week one. only for the following weeks
        #by the time week two arrives, the Primary infectors will have exhausted most of their pool of close friends, family and colleagues to share the app with. 
        #They will therefore have to work harder to find other people at the margins of the social circle to share the app with.
        #Their infection rate therefore slows down.
        #The Final assumption is that primary infectors will be most active in the first month. After that they'll slow down and behave like secondary infectors. 
        #This is because they are no longer being inventivised to share the malware. Allo of this is artiulated through the code structure below 

        if week_count < 5:
            #print("DEBUG: Entered 'if week_count is less than 5'")
            if week_count == 2:
                #reset the 'primariy_infectors' infection rate to be less effective. Introduce variance in different primary infectors infection rate 
                new_infection_rate = get_infection_rate(2)
                sick.infection_rate = new_infection_rate

            if week_count > 2:
                #reset the 'primary_infectors' rate to be even less effective. Continue varied infeciton rate 
                new_infection_rate = get_infection_rate(1)
                sick.infection_rate = new_infection_rate

            #perform infection simulation by primary infectors
            infection_attempts = sick.infection_rate
            if infection_attempts > 0 and sick.social_circle > 0:
                #use each infection rate as an attempt to infect someone with the malware....
                while infection_attempts > 0 and sick.social_circle > 0 and user_has_target_phone(iphone_users, android_users, other_users, target_device):
                    infect = attempt_infection()
                    #regardless of whether the infeciton is successful or not you must deduct one from the social circle size. 
                    sick.social_circle = sick.social_circle - 1
                    if infect:
                        infected_id = infected_id + 1
                        #print(("DEBUGG: INFECTION ID FOR NEXTSECONDARY  INFECTION {}".format(infected_id)))
                        #set infection rate of secondary infected to be between 0 and 1. It's assumed they will be much less active abotu sharing monzo sign up links than primary infectors
                        rate = get_infection_rate(1)
                        newley_infected.append(infected.Infected('secondary', rate, infected_id, sick.infection_id, get_social_circle_size('secondary')))
                    infection_attempts = infection_attempts - 1
        else:
            if new_week:
                #perform infection simulation by primary infectors
                infection_attempts = sick.infection_rate
                if infection_attempts > 0 and sick.social_circle > 0:
                    while infection_attempts > 0 and sick.social_circle > 0 and user_has_target_phone(iphone_users, android_users, other_users, target_device) :
                        infect = attempt_infection()
                        sick.social_circle = sick.social_circle -1
                        if infect:
                            infected_id = infected_id + 1
                            #print(("DEBUGG: INFECTION ID FOR NEXT SECONDARY INFECTION {}".format(infected_id)))
                            rate = get_infection_rate(1)
                            newley_infected.append(infected.Infected('secondary', rate, infected_id, sick.infection_id, get_social_circle_size('secondary')))
                        infection_attempts = infection_attempts - 1
                #NOTE: leave setting of `new_week` to `False` for the secondary infected otherwise their codeblock wont fire.  
            

    #SECONDARY INFECTED CODE BEGINS HERE...
    #secondary_infectors will infect at a much slower rate between zero and one infections per week. 
    #this only fires once a week so in reading the output you'll notice a constant rate in secondary infections for multiple entires, until it fires again in the following week
    if new_week:
        for sick in secondary_infected:
            infection_attempts = sick.infection_rate
            if infection_attempts > 0 and sick.social_circle > 0:
                while infection_attempts > 0 and sick.social_circle > 0 and user_has_target_phone(iphone_users, android_users, other_users, target_device):
                    infect = attempt_infection()
                    #minus one from the social circle size count each time the secondary infected attempts to share a link in there social circle.
                    sick.social_circle = sick.social_circle - 1
                    if infect:
                        infected_id = infected_id + 1
                        #print(("DEBUGG: INFECTION ID FOR NEXT TERTIARY INFECTION {}".format(infected_id)))
                        #set infection rate for tertiary infected...
                        rate  = get_infection_rate(1)
                        newley_infected.append(infected.Infected('tertiary', rate, infected_id, sick.infection_id, get_social_circle_size('tertiary')))
                    infection_attempts = infection_attempts - 1
        #set new week to false so that secondary infection attempts only occur once per week
        new_week = False

    #print(("Newley_infected size BEFORE DELETE: {}").format(len(newley_infected)))
    #finally append the_infected array
    if len(newley_infected) > 0:
        #print("firing extend secondary_infected array")
        secondary_infected.extend(newley_infected)
    #for thoroughness empty the 'newley_infected' list before the next itteration
    del newley_infected[:]

    #print(("Newley_infected size AFTER DELETE: {}").format(len(newley_infected)))
    #update total infection count
    infection_count = (len(primary_infected) + len(secondary_infected)) 

    #end of day report:

    if verbose_mode:
        print("CYCLE COUNT: {}".format(loop_count))
        print("WEEK: {}".format(week_count))
        print("DAY: {} ".format(day_count))
        print("PRIMARY INFECTED: {}".format(len(primary_infected)))
        print("SECONDARY INFECTED: {}".format(len(secondary_infected)))
        print("TOTAL INFECTED: {}".format(infection_count))
        print("\n")


    #finally, at end of the day clock the day has ended by adding one
    day_count = day_count + 1

    #update the loopcount. This is only for debugging purposes and should normally be commented out
    loop_count = loop_count + 1
print("************************ INFECTION TARGET REACHED **************************************")
print("WEEK: {}".format(week_count))
print("DAY: {} ".format(day_count))
print("TARGET TOTAL INFECTED: {}".format(infection_target))
print("FINAL TOTAL INFECTED: {}".format(infection_count))
